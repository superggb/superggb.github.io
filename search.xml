<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Spring_______SpringgMVC的基本流程</title>
      <link href="/2018/08/08/Spring-SpringgMVC%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B/"/>
      <url>/2018/08/08/Spring-SpringgMVC%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>–</p><p>说到SpringMVC自然少不了下面这张图：</p><hr><p><img src="http://i4.bvimg.com/656991/29f32a565f2f360e.jpg" alt="Markdown"></p><hr><p>从这张图我们可以很清晰地看到SpringMVC作为Spring内嵌的MVC模块其整体的工作流程：</p><ol><li>用户向服务器发送请求，请求被Spring 的前端控制器DispatcherServlet截获。</li><li>DispatherServlet对请求URL(统一资源定位符)进行解析，得到URI(请求资源标志符)，然后根据该uri，调用HandlerMapping获得该Handler配置的所有相关的对象。</li><li>DispatcherServlet根据获得的Handler，选择一个合适的HandlerAdapter。</li><li>提取请求中的模型数据，开始执行Handler(Controller)。期间Spring会自动帮你做一些工作：</li></ol><ul><li>消息转换</li><li>数据转换</li><li>数据格式化</li><li>数据验证</li></ul><ol start="5"><li>Handler执行完成后，向DispatcherServlet返回一个ModelAndView对象，ModelAndView对象中应该包含视图名或视图名和模型</li><li>根据返回的ModelAndView对象，选择一个合适的ViewResolver（视图解析器）返回给DispatcherServlet.</li><li>ViewResolver结合Model和View来渲染视图</li><li>将视图结果返回客户端</li></ol><hr><p>为了更清晰直观的描述其在程序中所发挥的作用，我觉得我们可以结合springMVC的配置文件说起：</p><h1 id="第一部分-web-xml"><a href="#第一部分-web-xml" class="headerlink" title="第一部分 web.xml"></a>第一部分 web.xml</h1><p>作为一个JavaWeb项目，无论使用什么框架，其本质还是得归根到JSP,Servlet上来，而其根本的配置信息就是由web.xml所配置的。作为SpringMVC中的控制转发器DispatcherServlet其本质也是个负责拦截请求并转发的Servlet，所以使用SpringMVC的第一步便是在web.xml配置好DispatherServlet.看下面的代码(省略头文件)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">!-- 配置DispathcherServlet --&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">       &lt;!--加载配置文件路径--&gt;</span><br><span class="line">        &lt;init-param&gt;</span><br><span class="line">            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">            &lt;param-value&gt;classpath:spring/spring-*.xml&lt;/param-value&gt;</span><br><span class="line">        &lt;/init-param&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure><p>如上便配置好了DispatherServlet,当然其中还有对springMVC本身的配置文件，以及之后spring与DAO层，service层的spring配置文件的路径说明也必须要添加到<init-param>…</init-param>之中去。</p><h1 id="第二部分-springmvc-config-xml"><a href="#第二部分-springmvc-config-xml" class="headerlink" title="第二部分 springmvc-config.xml"></a>第二部分 springmvc-config.xml</h1><p>这个文件配置的便是对springmvc的整体相关配置文件了，在 <em>SpringInAction</em> 一书中，作者推荐了采用java代码的方式对SpringMVC进行配置。</p><p>但就目前所流行的开发模式中，依然是采用.xml配置文件使配置与逻辑业务分离，我个人也更喜欢.xml的配置方式，但是在有些情况下，需要对不同地方按不同逻辑进行选择配置时，这时Java配置才展现出它的优点。</p><p>如下展示的是一个简单但可用的springmvc配置文件(文件名可以任取，只要在web.xml中配置好)，通过对其的解读，我们可见窥见一个完整的springmvc运作(头文件已省略)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置SpringMVC --&gt;</span><br><span class="line">    &lt;!-- 1：开启SpringMVC注解模式 --&gt;</span><br><span class="line">    &lt;!-- 简化配置：</span><br><span class="line">         （1）自动注册DefaultAnnotationHandlerMapping,AnnotationMethodHandlerAdapter</span><br><span class="line">         xml,json默认支持读写 --&gt;</span><br><span class="line">    &lt;mvc:annotation-driven/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 2:静态资源默认servlet配置</span><br><span class="line">         1）加入对静态资源的处理：js,gif,png</span><br><span class="line">         2) 允许使用&quot;/&quot;做整体映射</span><br><span class="line">         --&gt;</span><br><span class="line">    &lt;mvc:default-servlet-handler/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 3:配置jsp 显示ViewResolver --&gt;</span><br><span class="line">    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 4.spring可以自动扫描base-package下面的包或子包的java文件，当扫描到spring相关的类时，可自动注册 --&gt;</span><br><span class="line">    &lt;context:component-scan base-package=&quot;controller&quot;/&gt;</span><br></pre></td></tr></table></figure><ol><li><a href="mvc:annotation-driven/" target="_blank" rel="noopener">mvc:annotation-driven/</a></li></ol><p>这条语句会自动注册RequestMappingHandlerMapping与RequestMappingHandlerAdapter两个Bean，这是SpringMVC为@COntrollers分发请求所必需的，并提供数据绑定支持，读写XML的支持(JAXB)和读写JSON的支持(默认Jackson)等功能。</p><p>大部分情况我们使用默认的配置即可，但如果想要修改一些默认，如利用非Jackson处理json数据时，就需要在<a href="mvc:annotation-driven" target="_blank" rel="noopener">mvc:annotation-driven</a>标签中进行修改。</p><ol start="2"><li><a href="mvc:default-servlet-handler/" target="_blank" rel="noopener">mvc:default-servlet-handler/</a></li></ol><p>该语句使用默认的Servlet来响应静态文件，因为在web.xml中使用了DispatcherServlet截获所有请求url,所以在请求引入静态文件，例如js的引用语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;js/ggb.js&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>DispatherServlet会将”/“看成请求路径而报错。所以需要加上该语句进行配置。</p><ol start="3"><li>ViewResolver的配置</li></ol><p>通过该项配置，当我们通过controller返回一个视图名时，会自动加上前缀prefix和后缀suffix，这样可以简化我们的代码编写。</p><ol start="4"><li>&lt;context:component-scan base-package=”controller”/&gt;</li></ol><p>通过该语句，我们可以扫描到controller包下我们所写的controller组件，进而进行映射控制</p><hr><p>把每一个组件配置完成后，我们便可以开始使用springmvc进行业务逻辑控制，下面列举一个小例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class HelloWorldContoller&#123;</span><br><span class="line">    @RequestMapping(&quot;/helloworld&quot;)</span><br><span class="line">    public String helloWorld(Model model)&#123;</span><br><span class="line">        model.addAttribute(&quot;message&quot;,&quot;HelloWorld!&quot;);</span><br><span class="line">        return &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里便完成了一个极其简单的控制器实例了，首先我们通过@Contoller注解告诉spring这是一个控制器组件，之后的@RequestMapping(“/helloworld”)则声明以下方法用于处理url中的xxxx/helloworld请求，而计算机能识别此路径的前提，当然也是因为我们在web.xml中所声明的对’/‘的映射，以及springmvc.config中开启扫描后的结果。</p><p>请求处理方法中可以带多种参数，而最重要的便是Model和ModelAndView参数了，在MVC框架中，控制器执行业务逻辑后产生模型数据(Model)，而视图(View)则用于渲染模型数据。</p><p>在上例中，我们想model中加入了参数”HelloWorld!”，当其返回”hello”时，便会被自动解析为 ‘/WEB-INF/jsp/hello.jsp’ 这也是我们所配置的ViewResolver的功劳。这样，当我们在hello.jsp页面中通过EL表达式便可取到messge的值”HelloWorld!”输出到页面上了。</p><p>此时再回顾我们开篇所给出的SpringMVC的流程图，通过这个么一个简单的例子，便实现了从拦截请求，控制器处理，数据模型建立，视图解析这一个整个MVC的过程！</p><p>当然，要实现更加复杂的程序功能，还有很多SpringMVC注解如：</p><ul><li>@PathVariable 对请求的参数进行映射</li><li>@CookieValue 处理请求中的Cookie值</li><li>@RequestBody 自动将json数据参数传化为对应Pojo</li><li>@Response 自动将结果pojo转化为json格式</li><li>等等</li></ul><p>想了解更为详细的配置方法和注解使用，可以去阅读<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#spring-web" target="_blank" rel="noopener">官方文档</a>，或者查看其他网络资源。</p><blockquote><p>本文为GGB学习过程中的笔记总结，欢迎各位的指正和交流。</p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>README</title>
      <link href="/2018/08/07/README/"/>
      <url>/2018/08/07/README/</url>
      <content type="html"><![CDATA[<h2 id="这里主要是博客的介绍说明："><a href="#这里主要是博客的介绍说明：" class="headerlink" title="这里主要是博客的介绍说明："></a>这里主要是博客的介绍说明：</h2><ol><li>用于存放个人学习笔记和记录（有不同意见可以交流）</li><li>存放一些个人随笔</li><li>存放一些个人收集的网络资源</li><li>提供一个公开交流的平台</li><li>也是作为网络前端的一个测试点，以后可能随时会改变博客样式风格</li></ol>]]></content>
      
      
    </entry>
    
    <entry>
      <title>HELLO WORLD</title>
      <link href="/2018/08/07/HELLO%20WORLD/"/>
      <url>/2018/08/07/HELLO%20WORLD/</url>
      <content type="html"><![CDATA[<p>相信每一个程序员的第一行代码输出就是helloworld吧， 无论是接触到一门新的编程语言还是搭建好一个新的软件环境。我想无论是哪位程序员，看到这两个单词时都会有种莫名的亲切感吧。</p><p>–</p><p>当我们亲手用一行一行代码去实现一个又一个功能，让我们的生活，让这个世界，变得更加方便和智能，我觉得这也是代码本身向这个世界的一种展示，当我们使用着互联网，智能手机，个人电脑，感受着这个信息时代的便利时，一行一行代码也穿梭其间，可以说，这是一个代码的时代，溯源到其始端，也正是从1972年<em>贝尔实验室</em>在其 <em>Introduction to the Language B</em> 使用hello world,作为程序第一个输出开始，代码开始向这个世界输出自己的力量。</p><p>–</p><p>所以，作为程序猿从某种意义上来说也是伟大的，我们用智慧写出一行行代码来构建这个世界，We are creating the world !</p><p>–</p><p>电影 <em>模仿游戏</em> 里面图灵有这样的说法，<em>“can mechaines think? just because they think diffently from us? ”</em> 当我们用代码构建一层层神经网络，企图让机器去自己思考，让机器去认识这个世界的时候，我们能否认其所输出的hello world不正是它向这个世界问好吗？当计算机在代码驱动下，能认识一朵花，一只猫或者一条狗的时候，这不正是人类婴儿时期，在懵懂中开始对世界产生认知吗？在我看来，机器像人类一样思考或者说能思考得像人类，it’s just a matter of time.</p><p>–</p><p>hello world 也是我搭建好这个博客后自动生成的文章标题，我觉得作为一个程序猿的博客，以hello world开头也是再好不过的了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Printf(&quot;hello world!&quot;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
  
  
    
  
</search>
