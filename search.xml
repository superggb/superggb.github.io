<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>开启SpringBoot的新世界</title>
      <link href="/2018/08/13/%E5%BC%80%E5%90%AFSpringBoot%E7%9A%84%E6%96%B0%E4%B8%96%E7%95%8C/"/>
      <url>/2018/08/13/%E5%BC%80%E5%90%AFSpringBoot%E7%9A%84%E6%96%B0%E4%B8%96%E7%95%8C/</url>
      <content type="html"><![CDATA[<p>–<br>之前一直在折腾SSM框架，几番下来也算是对SpringMVC+Spring+Mybatis的基本使用逻辑和思路有了一些清晰的思路。框架的开发模式确实比传统的纯JavaBean和Servlet的开发更高效且结构更加清晰。但是，我也并未打算就此停住来享受SSM框架的便利。因为，在接触Spring框架之初，早已听说了Spring的另一个项目——SpringBoot,这是一个更加简洁高效框架。在阅读 <em>SpringInAction</em> 一书时，作者在最后便提出了SpringBoot,称其是一个改变游戏规则的产品，之所以放在全书最后是为了让读者能更好理解Spring，但是他也说了，或许在下一版的书中，我们将会在全书开篇就看见SpringBoot的身影。这也说明SpringBoot所拥有的无限潜力。</p><p>此篇博客是我第一次接触SpringBoot后的体会和学习总结，其主要内容源自于<a href="https://spring.io/guides/gs/rest-service/" target="_blank" rel="noopener">SpringBoot的官方文档开篇</a>。</p><h2 id="一-使用Spring-Initializr-快速搭建SpringBoot项目"><a href="#一-使用Spring-Initializr-快速搭建SpringBoot项目" class="headerlink" title="一.使用Spring Initializr 快速搭建SpringBoot项目"></a>一.使用Spring Initializr 快速搭建SpringBoot项目</h2><p>在Idea环境下，新建项目，选择Spring Initializr，直接点击next。</p><p><a href="https://imgchr.com/i/PWaYjK" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/08/17/PWaYjK.md.png" alt="PWaYjK.md.png"></a></p><p>选择使用Mavean构建项目</p><p><a href="https://imgchr.com/i/PWaJc6" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/08/17/PWaJc6.md.png" alt="PWaJc6.md.png"></a></p><p>选择Web项目，Idea会自动选择最新的SpringBoot版本，<br><a href="https://imgchr.com/i/PWaNnO" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/08/17/PWaNnO.md.png" alt="PWaNnO.md.png"></a></p><p>自此，便创建好了一个完整配置的SpringBoot项目，观察其pom.xml文件，可以发现其已经引进相关的SpringBoot的配置。</p><h2 id="二-创建第一个RESTful-Web-Service"><a href="#二-创建第一个RESTful-Web-Service" class="headerlink" title="二.创建第一个RESTful Web Service"></a>二.创建第一个RESTful Web Service</h2><p>此次运行目标是通过一个HTTP GET REQUSET:</p><blockquote><p><a href="http://localhost:8080/greeting" target="_blank" rel="noopener">http://localhost:8080/greeting</a></p></blockquote><p>得到返回的json格式数据：</p><blockquote><p>{“id”:1,”content”:”Hello, World!”}</p></blockquote><p>也可以传递一个名为name的参数改变返回值：</p><blockquote><p><a href="http://localhost:8080/greeting?name=ggb" target="_blank" rel="noopener">http://localhost:8080/greeting?name=ggb</a></p></blockquote><blockquote><p>{“id”:1,”content”:”Hello, ggb!”}</p></blockquote><p>现在我们开始此项目的正式编码：</p><h3 id="1-创建一个名为hello的javabean"><a href="#1-创建一个名为hello的javabean" class="headerlink" title="1.创建一个名为hello的javabean"></a>1.创建一个名为hello的javabean</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class hello &#123;</span><br><span class="line">    private long id;</span><br><span class="line">    private String content;</span><br><span class="line"></span><br><span class="line">    public hello(long id, String content) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getContent() &#123;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并实现其getter方法。</p><h3 id="2-创建Controller"><a href="#2-创建Controller" class="headerlink" title="2.创建Controller"></a>2.创建Controller</h3><p>创建一个名为GreetingController的Java类如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class GreetingController &#123;</span><br><span class="line">    private static final String template = &quot;Hello,%s!&quot;;</span><br><span class="line">    private final AtomicLong counter=new AtomicLong();</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/greeting&quot;)</span><br><span class="line">    public com.ggb.dao.hello greeting(@RequestParam(value=&quot;name&quot;,defaultValue = &quot;World&quot;)String name)&#123;</span><br><span class="line">        return new hello(counter.incrementAndGet(),String.format(template,name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，注解 <em>@RestController</em>为Spring4里的新注解，它包含了 <em> </em>@Controller<em> 和 </em>@ResponseBody* 两个注解的功能。</p><p><em>@ResqusetMapping</em> 同样表示映射地址为”/greeting”。</p><p><em>@RequestParam</em> 将请求参数与方法参数进行绑定，并设置默认值为”World”。</p><p>counter变量用于请求计数。如此便完成了Conroller的编码。</p><h3 id="3-运行SpringBoot"><a href="#3-运行SpringBoot" class="headerlink" title="3.运行SpringBoot"></a>3.运行SpringBoot</h3><p>刚完成项目构建时，我们便发现了SpringBoot已经自动给我们生成了一个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <em>@SpringBootApplication</em> 注解囊括了一下所有功能：</p><ol><li><em>@Configuration</em> ，即声明为一个配置类</li><li><em>@EnableAutoConfiguration</em> ，告诉SpringBoot自动配置加载其他Beans，和相关设定。</li><li>类似于DispatcherServlet，此声明使得其拥有SpringMVC的拦截转发功能。</li><li><em>@ConponentScan</em> 告诉Spring寻找其他组件，配置和服务在当前包下，并查找Controllers</li></ol><p>于此，通过一个注解我们便完成了之前我们所需配置的一系列xml等的工作。需要前两个Java类放在main的同一个包下。</p><p>由于SpringBoot内置了tomcat容器，所以此时，只需要点击Application方法旁边的运行按钮，SpringBoot便可自动构建JAR文件，完成整个项目运行，并达到预期效果。当然，也可以通过传统方式，将整个项目打包成WAR文件再放置于第三方的容器运行。</p><h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h2><p>当第一次接触到SpringBoot，我便被其所带来的巨大的便利性所深深吸引。在此之前，即使框架给我们带来了结构性的设计模式，和各个类之间的关系解耦。但是，从dao层到service层，再到controller每一层结构所需要的配置都是比较繁杂的。所以，当接触到SpringBoot，其带来的喜悦和兴奋感是难以言喻的，它的出现是真正改变游戏规则的那个。以后，我也一定会对其进行深入的学习和探究的。</p><blockquote><p>本文为ggb学习总结笔记和感想，若有不足或错误，欢迎指正交流</p></blockquote>]]></content>
      
      <categories>
          
          <category> GGB&#39;学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring_______SpringMVC的基本流程</title>
      <link href="/2018/08/08/Spring-SpringMVC%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B/"/>
      <url>/2018/08/08/Spring-SpringMVC%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h1 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h1><p>说到SpringMVC可以先看下面这张图：</p><hr><p><a href="https://imgchr.com/i/PWa7vV" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/08/17/PWa7vV.md.jpg" alt="PWa7vV.md.jpg"></a></p><hr><p>从这张图我们可以很清晰地看到SpringMVC作为Spring内嵌的MVC模块其整体的工作流程：</p><ol><li>用户向服务器发送请求，请求被Spring 的前端控制器DispatcherServlet截获。</li><li>DispatherServlet对请求URL(统一资源定位符)进行解析，得到URI(请求资源标志符)，然后根据该uri，调用HandlerMapping获得该Handler配置的所有相关的对象。</li><li>DispatcherServlet根据获得的Handler，选择一个合适的HandlerAdapter。</li><li>提取请求中的模型数据，开始执行Handler(Controller)。期间Spring会自动帮你做一些工作：</li></ol><ul><li>消息转换</li><li>数据转换</li><li>数据格式化</li><li>数据验证</li></ul><ol start="5"><li>Handler执行完成后，向DispatcherServlet返回一个ModelAndView对象，ModelAndView对象中应该包含视图名或视图名和模型</li><li>根据返回的ModelAndView对象，选择一个合适的ViewResolver（视图解析器）返回给DispatcherServlet.</li><li>ViewResolver结合Model和View来渲染视图</li><li>将视图结果返回客户端</li></ol><hr><p>为了更清晰直观的描述其在程序中所发挥的作用，我觉得我们可以结合springMVC的配置文件说起：</p><h1 id="第一部分-web-xml"><a href="#第一部分-web-xml" class="headerlink" title="第一部分 web.xml"></a>第一部分 web.xml</h1><p>作为一个JavaWeb项目，无论使用什么框架，其本质还是得归根到JSP,Servlet上来，而其根本的配置信息就是由web.xml所配置的。作为SpringMVC中的控制转发器DispatcherServlet其本质也是个负责拦截请求并转发的Servlet，所以使用SpringMVC的第一步便是在web.xml配置好DispatherServlet.看下面的代码(省略头文件)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">!-- 配置DispathcherServlet --&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">       &lt;!--加载配置文件路径--&gt;</span><br><span class="line">        &lt;init-param&gt;</span><br><span class="line">            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">            &lt;param-value&gt;classpath:spring/spring-*.xml&lt;/param-value&gt;</span><br><span class="line">        &lt;/init-param&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure><p>如上便配置好了DispatherServlet,当然其中还有对springMVC本身的配置文件，以及之后spring与DAO层，service层的spring配置文件的路径说明也必须要添加到<init-param>…</init-param>之中去。</p><h1 id="第二部分-springmvc-config-xml"><a href="#第二部分-springmvc-config-xml" class="headerlink" title="第二部分 springmvc-config.xml"></a>第二部分 springmvc-config.xml</h1><p>这个文件配置的便是对springmvc的整体相关配置文件了，在 <em>SpringInAction</em> 一书中，作者推荐了采用java代码的方式对SpringMVC进行配置。</p><p>但就目前所流行的开发模式中，依然是采用.xml配置文件使配置与逻辑业务分离，我个人也更喜欢.xml的配置方式，但是在有些情况下，需要对不同地方按不同逻辑进行选择配置时，这时Java配置才展现出它的优点。</p><p>如下展示的是一个简单但可用的springmvc配置文件(文件名可以任取，只要在web.xml中配置好)，通过对其的解读，我们可见窥见一个完整的springmvc运作(头文件已省略)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置SpringMVC --&gt;</span><br><span class="line">    &lt;!-- 1：开启SpringMVC注解模式 --&gt;</span><br><span class="line">    &lt;!-- 简化配置：</span><br><span class="line">         （1）自动注册DefaultAnnotationHandlerMapping,AnnotationMethodHandlerAdapter</span><br><span class="line">         xml,json默认支持读写 --&gt;</span><br><span class="line">    &lt;mvc:annotation-driven/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 2:静态资源默认servlet配置</span><br><span class="line">         1）加入对静态资源的处理：js,gif,png</span><br><span class="line">         2) 允许使用&quot;/&quot;做整体映射</span><br><span class="line">         --&gt;</span><br><span class="line">    &lt;mvc:default-servlet-handler/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 3:配置jsp 显示ViewResolver --&gt;</span><br><span class="line">    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 4.spring可以自动扫描base-package下面的包或子包的java文件，当扫描到spring相关的类时，可自动注册 --&gt;</span><br><span class="line">    &lt;context:component-scan base-package=&quot;controller&quot;/&gt;</span><br></pre></td></tr></table></figure><ol><li><a href="mvc:annotation-driven/" target="_blank" rel="noopener">mvc:annotation-driven/</a></li></ol><p>这条语句会自动注册RequestMappingHandlerMapping与RequestMappingHandlerAdapter两个Bean，这是SpringMVC为@COntrollers分发请求所必需的，并提供数据绑定支持，读写XML的支持(JAXB)和读写JSON的支持(默认Jackson)等功能。</p><p>大部分情况我们使用默认的配置即可，但如果想要修改一些默认，如利用非Jackson处理json数据时，就需要在<a href="mvc:annotation-driven" target="_blank" rel="noopener">mvc:annotation-driven</a>标签中进行修改。</p><ol start="2"><li><a href="mvc:default-servlet-handler/" target="_blank" rel="noopener">mvc:default-servlet-handler/</a></li></ol><p>该语句使用默认的Servlet来响应静态文件，因为在web.xml中使用了DispatcherServlet截获所有请求url,所以在请求引入静态文件，例如js的引用语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;js/ggb.js&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>DispatherServlet会将”/“看成请求路径而报错。所以需要加上该语句进行配置。</p><ol start="3"><li>ViewResolver的配置</li></ol><p>通过该项配置，当我们通过controller返回一个视图名时，会自动加上前缀prefix和后缀suffix，这样可以简化我们的代码编写。</p><ol start="4"><li>&lt;context:component-scan base-package=”controller”/&gt;</li></ol><p>通过该语句，我们可以扫描到controller包下我们所写的controller组件，进而进行映射控制</p><hr><p>把每一个组件配置完成后，我们便可以开始使用springmvc进行业务逻辑控制，下面列举一个小例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class HelloWorldContoller&#123;</span><br><span class="line">    @RequestMapping(&quot;/helloworld&quot;)</span><br><span class="line">    public String helloWorld(Model model)&#123;</span><br><span class="line">        model.addAttribute(&quot;message&quot;,&quot;HelloWorld!&quot;);</span><br><span class="line">        return &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里便完成了一个极其简单的控制器实例了，首先我们通过@Contoller注解告诉spring这是一个控制器组件，之后的@RequestMapping(“/helloworld”)则声明以下方法用于处理url中的xxxx/helloworld请求，而计算机能识别此路径的前提，当然也是因为我们在web.xml中所声明的对’/‘的映射，以及springmvc.config中开启扫描后的结果。</p><p>请求处理方法中可以带多种参数，而最重要的便是Model和ModelAndView参数了，在MVC框架中，控制器执行业务逻辑后产生模型数据(Model)，而视图(View)则用于渲染模型数据。</p><p>在上例中，我们想model中加入了参数”HelloWorld!”，当其返回”hello”时，便会被自动解析为 ‘/WEB-INF/jsp/hello.jsp’ 这也是我们所配置的ViewResolver的功劳。这样，当我们在hello.jsp页面中通过EL表达式便可取到messge的值”HelloWorld!”输出到页面上了。</p><p>此时再回顾我们开篇所给出的SpringMVC的流程图，通过这个么一个简单的例子，便实现了从拦截请求，控制器处理，数据模型建立，视图解析这一个整个MVC的过程！</p><p>当然，要实现更加复杂的程序功能，还有很多SpringMVC注解如：</p><ul><li>@PathVariable 对请求的参数进行映射</li><li>@CookieValue 处理请求中的Cookie值</li><li>@RequestBody 自动将json数据参数传化为对应Pojo</li><li>@Response 自动将结果pojo转化为json格式</li><li>等等</li></ul><p>想了解更为详细的配置方法和注解使用，可以去阅读<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#spring-web" target="_blank" rel="noopener">官方文档</a>，或者查看其他网络资源。</p><blockquote><p>本文为GGB学习过程中的笔记总结，欢迎各位的指正和交流。</p></blockquote>]]></content>
      
      <categories>
          
          <category> GGB&#39;学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>README</title>
      <link href="/2018/08/07/README/"/>
      <url>/2018/08/07/README/</url>
      <content type="html"><![CDATA[<h2 id="这里主要是博客的介绍说明："><a href="#这里主要是博客的介绍说明：" class="headerlink" title="这里主要是博客的介绍说明："></a>这里主要是博客的介绍说明：</h2><ol><li>用于存放个人学习笔记和记录（有不同意见可以交流）</li><li>存放一些个人随笔</li><li>存放一些个人收集的网络资源</li><li>提供一个公开交流的平台</li><li>也是作为网络前端的一个测试点，以后可能随时会改变博客样式风格</li></ol>]]></content>
      
      
    </entry>
    
    <entry>
      <title>HELLO WORLD</title>
      <link href="/2018/08/07/HELLO%20WORLD/"/>
      <url>/2018/08/07/HELLO%20WORLD/</url>
      <content type="html"><![CDATA[<p>相信每一个程序员的第一行代码输出就是helloworld吧， 无论是接触到一门新的编程语言还是搭建好一个新的软件环境。我想无论是哪位程序员，看到这两个单词时都会有种莫名的亲切感吧。</p><p>–</p><p>当我们亲手用一行一行代码去实现一个又一个功能，让我们的生活，让这个世界，变得更加方便和智能，我觉得这也是代码本身向这个世界的一种展示，当我们使用着互联网，智能手机，个人电脑，感受着这个信息时代的便利时，一行一行代码也穿梭其间，可以说，这是一个代码的时代，溯源到其始端，也正是从1972年<em>贝尔实验室</em>在其 <em>Introduction to the Language B</em> 使用hello world,作为程序第一个输出开始，代码开始向这个世界输出自己的力量。</p><p>–</p><p>所以，作为程序猿从某种意义上来说也是伟大的，我们用智慧写出一行行代码来构建这个世界，We are creating the world !</p><p>–</p><p>电影 <em>模仿游戏</em> 里面图灵有这样的说法，<em>“can mechaines think? just because they think diffently from us? ”</em> 当我们用代码构建一层层神经网络，企图让机器去自己思考，让机器去认识这个世界的时候，我们能否认其所输出的hello world不正是它向这个世界问好吗？当计算机在代码驱动下，能认识一朵花，一只猫或者一条狗的时候，这不正是人类婴儿时期，在懵懂中开始对世界产生认知吗？在我看来，机器像人类一样思考或者说能思考得像人类，it’s just a matter of time.</p><p>–</p><p>hello world 也是我搭建好这个博客后自动生成的文章标题，我觉得作为一个程序猿的博客，以hello world开头也是再好不过的了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Printf(&quot;hello world!&quot;)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> GGB&#39;随笔 </category>
          
      </categories>
      
      
    </entry>
    
  
  
    
  
</search>
